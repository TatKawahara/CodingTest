# 本ファイルについて
解法やコードの説明を行います。

## 解法について

### 前提と基本方針
駅を頂点、線路を辺に見立てたグラフを考えると、求めるべきものは非負の重み付きグラフの最長経路であることが分かります。これを効率よく（多項式時間で）解くアルゴリズムは現在見つかっていません。

頂点数（コードでは `node_num`）によって異なるアプローチをとります。頂点数が少ないときは指数時間アルゴリズムを用いて最長経路を正確に求めます。頂点数が多いときは、乱択を利用したアルゴリズムを用いてできる限り長い経路を求めます。

### ステップ1. 座標圧縮
「数列の中でその値が何番目に小さいか」を記録します。

例えば、入力で与えられる駅の ID が $1, 100, 250, 1000$ の 4 つの場合、これをそれぞれ $0, 1, 2, 3$ に変換します。（この変換が、数直線上の点たちを圧縮しているように見えるためしばしば「座標圧縮」と呼ばれます。）

こうすることで、上の例だと ID をそのまま用いて距離を計算する際は約 1000 のサイズの配列を用意する必要がありますが、座標圧縮をすることで用意する配列のサイズが 4 で済み、メモリの消費を抑えられます。他にも様々な実装上のメリットがあります。

### ステップ2-a. 頂点数が少ないとき
動的計画法を用います。

$dp[S][v]$ を「今までに訪れた頂点の集合が $S$ で、現在頂点 $v$ にいる状態になるまでにかかる距離の最大値」とします。

$S$ は 2 進数にしたときに (訪れた頂点) 目のビットを 1 にすることで表します。例えば、頂点 $0, 1, 2, 3, 4$ のうち頂点 $0, 3, 4$ のみが訪問済みの場合、 $S = 11001_{(2)} = 25_{(10)}$ となります。

$dp[S][v]$ は次のように遷移します:

- 頂点 $v$ と長さ $d$ の辺を伝って隣接する、未訪問の頂点を $nv$ とする。このとき、
  $dp[S|2^{nv}][nv] = max(dp[S|2^{nv}][nv], dp[S][v] + d)$

初期値を適切に設定したうえで、 $S$ の小さい順に $dp$ を遷移させていくことでアルゴリズムは正しく動きます。また、遷移時に最大値を更新した際に、「どの状態から遷移したのか」を管理する (コードでは `previous_transition`) ことで、経路を復元することができます。

### ステップ2-b. 頂点数が多いとき
焼きなまし法を用います。

まず、次のような手順で初期解を構成します:
- 頂点 $0$ からスタートして、通ることができる辺のうち最長のものを渡って隣接する頂点へ移動する。
- 通ることができる辺がなくなったら (つまり、隣接する頂点がすべて訪問済みになったら) 終了する。

近傍は次のように構成します (説明が複雑なので、下の具体例も参考にしてください):
- 暫定解の経路から区間を 1 つランダムに選び、削除する。
  - 選ばれた区間がもとの経路の端点を含んでいない場合 (つまり、暫定解の経路が 2 つに分裂した場合)

    分裂した経路をつなぐような経路のうち、距離が最長のものを探す。探索には深さ優先探索 (DFS) を用いる。

  - 選ばれた区間がもとの経路の端点を含んでいる場合
 
    削除されていない側の端点からスタートして、初期解を構成したときと同じ貪欲法を用いて新たな経路を作成する。

例えば、暫定解の経路 (頂点番号) が $[2, 1, 3, 0, 5]$ だとします。
- 選ばれた区間が $[1, 3]$ の場合、削除後の経路は $[2]$ と $[0, 5]$ に分裂します。そこで、頂点 $2$ から頂点 $0$ へ行く経路のうち最長のものを DFS で探し、 $[2, ...,0, 5]$ という経路を作成します。
- 選ばれた区間が $[2, 1, 3]$ の場合、削除後の経路は $[0, 5]$ です。そこで、頂点 $5$ からスタートして「通ることができる最長の辺を通って隣接する頂点に行く」ことを繰り返して $[0, 5, ..., ]$ という経路を作成します。
