# 本ファイルについて
解法やコードの説明を行います。

## 解法

### 前提と基本方針
駅を頂点、線路を辺に見立てたグラフを考えると、求めるべきものは非負の重み付きグラフの最長経路であることが分かります。これを効率よく（多項式時間で）解くアルゴリズムは現在見つかっていません。

頂点数（コードでは `node_num`）によって異なるアプローチをとります。頂点数が少ないときは指数時間アルゴリズムを用いて最長経路を正確に求めます。頂点数が多いときは、乱択を利用したアルゴリズムを用いてできる限り長い経路を求めます。

### ステップ1. ID の座標圧縮
座標圧縮とは、配列 (主に数列) の要素を、大小関係を保ったまま小さい値にすることです。各要素を、「配列の中でその値が何番目に小さいか」に変換します。今回は駅の ID に対してこのアルゴリズムを適用します。

例えば、入力で与えられる駅の ID が $1, 100, 250, 1000$ の 4 つの場合、これをそれぞれ $0, 1, 2, 3$ に変換します。（数直線上の点たちを圧縮するイメージです。）

こうすることで、上の例だと ID をそのまま用いて距離を計算する際は約 1000 のサイズの配列を用意する必要がありますが、座標圧縮をすることで用意する配列のサイズが 4 で済み、メモリの消費を抑えられます。他にも様々なメリットがあります。

### ステップ2-a. 頂点数が少ないとき
動的計画法を用います。

$dp[S][v]$ を「今までに訪れた頂点の集合が $S$ で、現在頂点 $v$ にいる状態になるまでにかかる距離の最大値」とします (実装では `dp_table[set][node]` としています)。

$S$ は 2 進数にしたときに (訪れた頂点) 目のビットを 1 にすることで表します。例えば、頂点 $0, 1, 2, 3, 4$ のうち頂点 $0, 3, 4$ のみが訪問済みの場合、 $S = 11001_{(2)} = 25_{(10)}$ となります。

$dp[S][v]$ は次のように遷移します:

- 頂点 $v$ と長さ $d$ の辺を伝って隣接する、未訪問の頂点を $nv$ とする。このとき、
  $dp[S|2^{nv}][nv] = max(dp[S|2^{nv}][nv], dp[S][v] + d)$

初期値を適切に設定したうえで、 $S$ の小さい順に $dp$ を遷移させていくことでアルゴリズムは正しく動きます。また、遷移時に最大値を更新した際に、「どの状態から遷移したのか」を管理する (コードでは `previous_transition`) ことで、経路を復元することができます。

### ステップ2-b. 頂点数が多いとき
焼きなまし法を用います。

初期解は、次のような貪欲法で構築します:
- 頂点 $0$ からスタートして、通ることができる辺のうち最長のものを渡って隣接する頂点へ移動する。
- 通ることができる辺がなくなったら (つまり、隣接する頂点がすべて訪問済みになったら) 終了する。

近傍は次のように構築します (説明が複雑なので、下の具体例も参考にしてください):
- 暫定解の経路から区間を 1 つランダムに選び、削除する。
- 選ばれた区間の特徴に応じて、以下のいずれかの処理を行う:
  - 選ばれた区間がもとの経路の端点を含んでいない場合 (暫定解の経路が 2 つに分裂した場合)

    分裂した経路を繋ぐような経路のうち、距離が最長のものを探す。探索には深さ優先探索 (DFS) を用いる。

  - 選ばれた区間がもとの経路の端点を含んでいる場合
 
    削除されていない側の端点からスタートして、初期解を構成したときと同じ貪欲法を用いて経路を伸ばす。

例えば、暫定解の経路 (頂点番号) が $[2, 1, 3, 0, 5]$ だとします。
- 選ばれた区間が $[1, 3]$ のとき、暫定解の経路は $[2]$ と $[0, 5]$ に分裂します。この場合、頂点 $2$ と頂点 $0$ を繋ぐ経路のうち最長のものを DFS で探し、 $[2, ...,0, 5]$ という経路を近傍とします。
- 選ばれた区間が $[2, 1, 3]$ のとき、削除後の経路は $[0, 5]$ です。この場合、頂点 $5$ からスタートして「通ることができる最長の辺を通って隣接する頂点に行く」ことを繰り返して $[0, 5, ..., ]$ という経路を近傍とします。
