# 本ファイルについて
解法やコードの説明を行います。

## 解法について

### 前提と基本方針
駅を頂点、線路を辺に見立てたグラフを考えると、求めるべきものは非負の重み付きグラフの最長経路であることが分かります。これを効率よく（多項式時間で）解くアルゴリズムは現在見つかっていません。

頂点数（コードでは `node_num`）によって異なるアプローチをとります。頂点数が少ないときは指数時間アルゴリズムを用いて最長経路を正確に求めます。頂点数が多いときは、乱択を利用したアルゴリズムを用いてできる限り長い経路を求めます。

### ステップ1. 座標圧縮
「数列の中でその値が何番目に小さいか」を記録します。

例えば、入力で与えられる駅の ID が $1, 100, 250, 1000$ の 4 つの場合、これをそれぞれ $0, 1, 2, 3$ に変換します。（この変換が、数直線上の点たちを圧縮しているように見えるためしばしば「座標圧縮」と呼ばれます。）

こうすることで、上の例だと ID をそのまま用いて距離を計算する際は約 1000 のサイズの配列を用意する必要がありますが、座標圧縮をすることで用意する配列のサイズが 4 で済み、メモリの消費を抑えられます。他にも様々な実装上のメリットがあります。

### ステップ2-a. 頂点数が少ないとき
動的計画法を用います。

$dp[S][v]$ を「今までに訪れた頂点の集合が $S$ で、現在頂点 $v$ にいる状態になるまでにかかる距離の最大値」とします。

$S$ は 2 進数にしたときに (訪れた頂点) 目のビットを 1 にすることで表します。例えば、頂点 $0, 1, 2, 3, 4$ のうち頂点 $0, 3, 4$ のみが訪問済みの場合、 $S = 11001_{(2)} = 25_{(10)}$ となります。

$dp[S][v]$ は次のように遷移します:

- 頂点 $v$ と長さ $d$ の辺を伝って隣接する、未訪問の頂点を $nv$ とする。このとき、
  $dp[S|2^{nv}][nv] = max(dp[S|2^{nv}][nv], dp[S][v] + d)$

初期値を適切に設定したうえで、 $S$ の小さい順に遷移させていくことでアルゴリズムは正しく動きます。また、遷移時に最大値を更新した際に、「どの状態から遷移したのか」を管理する (コードでは 'previous_transition') ことで、経路を復元することができます。
